<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>월별 생일자 목록</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pretendard/1.3.8/static/pretendard.css">
    <script src="https://unpkg.com/solarlunar@2.0.4/lib/solarlunar.min.js" 
            onerror="console.error('solarlunar.js 로드 실패. 음력 변환이 작동하지 않을 수 있습니다.');"></script>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: 'Pretendard', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
        }

        body {
            background-color: #F5F5F7;
            padding: 20px;
            color: #1A1A1A;
            line-height: 1.6;
        }

        .container {
            width: 100%;
            max-width: 560px;
            margin: 0 auto;
            background-color: white;
            border-radius: 20px;
            padding: 32px;
            box-shadow: 0 4px 20px rgba(123, 74, 255, 0.08);
        }

        .page-title {
            font-size: 32px;
            font-weight: bold;
            color: #1A1A1A;
            margin-bottom: 8px;
        }

        .section-title {
            font-size: 24px;
            font-weight: bold;
            color: #7B4AFF;
            margin-bottom: 24px;
        }

        .header {
            margin-bottom: 32px;
        }

        .controls {
            display: flex;
            gap: 16px;
            align-items: flex-start;
            margin-top: 24px;
        }
        
        .filter-section {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-bottom: 16px;
        }
        
        .filter-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .filter-stats {
            color: #7B4AFF;
            font-size: 14px;
            font-weight: 500;
        }
        
        .reset-button {
            background: none;
            border: none;
            color: #666666;
            font-size: 14px;
            cursor: pointer;
            text-decoration: underline;
            padding: 4px 8px;
        }
        
        .reset-button:hover {
            color: #7B4AFF;
        }

        select {
            padding: 12px 16px;
            border-radius: 12px;
            border: 1px solid #DDDDDD;
            font-size: 16px;
            background-color: white;
            color: #666666;
            width: 100%;
            transition: border-color 0.3s, box-shadow 0.3s;
            appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' viewBox='0 0 24 24' fill='none' stroke='%237B4AFF' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M6 9l6 6 6-6'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 12px center;
            padding-right: 40px;
            cursor: pointer;
        }

        select:focus {
            outline: none;
            border-color: #7B4AFF;
            box-shadow: 0 0 0 2px rgba(123, 74, 255, 0.2);
        }

        .select-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
            flex: 1;
        }

        .select-label {
            color: #666666;
            font-size: 14px;
            font-weight: 500;
        }

        .birthday-list {
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .birthday-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 16px 20px;
            background-color: #F5F5F7;
            border-radius: 16px;
            transition: transform 0.2s, box-shadow 0.2s;
            position: relative;
        }

        .birthday-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
        }

        .birthday-item::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: 4px;
            background-color: #7B4AFF;
            border-top-left-radius: 16px;
            border-bottom-left-radius: 16px;
        }

        .name-position {
            font-size: 18px;
            font-weight: 600;
            color: #1A1A1A;
        }

        .department {
            font-size: 14px;
            color: #666666;
            margin-top: 4px;
        }

        .birthday-info {
            background-color: white;
            padding: 8px 14px;
            border-radius: 12px;
            font-size: 14px;
            font-weight: 500;
            color: #7B4AFF;
            border: 1px solid rgba(123, 74, 255, 0.2);
            line-height: 1.6;
        }
        
        .birthday-info.lunar {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            gap: 4px;
        }
        
        .lunar-original {
            font-size: 14px;
        }
        
        .lunar-converted {
            font-size: 14px;
            padding-left: 8px;
        }

        .no-birthdays {
            text-align: center;
            padding: 32px 20px;
            color: #666666;
            background-color: #F5F5F7;
            border-radius: 16px;
            font-size: 16px;
        }

        .timestamp {
            text-align: center;
            font-size: 14px;
            margin-top: 32px;
            color: #666666;
        }
        
        .dot-decoration {
            display: flex;
            justify-content: center;
            margin: 16px 0;
        }
        
        .dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background-color: #DDDDDD;
            margin: 0 4px;
        }
        
        .dot.active {
            background-color: #7B4AFF;
        }
        
        /* 로딩 애니메이션 */
        .loading {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 40px 20px;
            color: #666666;
            gap: 16px;
        }
        
        .loading-spinner {
            width: 40px;
            height: 40px;
            border: 3px solid rgba(123, 74, 255, 0.2);
            border-radius: 50%;
            border-top-color: #7B4AFF;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* 재시도 버튼 */
        .retry-button {
            background-color: #7B4AFF;
            color: white;
            border: none;
            border-radius: 12px;
            padding: 10px 20px;
            margin-top: 16px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: background-color 0.3s;
        }
        
        .retry-button:hover {
            background-color: #6B3AD8;
        }
        
        /* 생일 카드 트랜지션 개선 */
        .birthday-list {
            position: relative;
        }
        
        .birthday-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 16px 20px;
            background-color: #F5F5F7;
            border-radius: 16px;
            transition: all 0.2s ease-out;
            position: relative;
            transform-origin: center;
            animation: fadeIn 0.3s ease-out;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        @media (max-width: 560px) {
            .container {
                padding: 24px;
            }
            
            .controls {
                flex-direction: column;
            }
            
            .select-group {
                width: 100%;
            }
            
            .page-title {
                font-size: 28px;
            }
            
            .section-title {
                font-size: 20px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1 class="page-title">월별 생일자 목록</h1>
            <h2 class="section-title">생일을 축하합니다</h2>
        </div>
        
        <div class="filter-section">
            <div class="filter-header">
                <div class="filter-stats" id="filterStats">총 0명</div>
                <button id="resetFilters" class="reset-button">필터 초기화</button>
            </div>
            <div class="controls">
                <div class="select-group">
                    <label class="select-label">월 선택</label>
                    <select id="monthSelect">
                        <option value="all">전체</option>
                        <option value="1">1월</option>
                        <option value="2">2월</option>
                        <option value="3">3월</option>
                        <option value="4">4월</option>
                        <option value="5">5월</option>
                        <option value="6">6월</option>
                        <option value="7">7월</option>
                        <option value="8">8월</option>
                        <option value="9">9월</option>
                        <option value="10">10월</option>
                        <option value="11">11월</option>
                        <option value="12">12월</option>
                    </select>
                </div>
                <div class="select-group">
                    <label class="select-label">소속 선택</label>
                    <select id="departmentSelect">
                        <option value="all">전체</option>
                        <option value="장년부">장년부</option>
                        <option value="청년부">청년부</option>
                        <option value="고등부">고등부</option>
                        <option value="중등부">중등부</option>
                        <option value="주일학교">주일학교</option>
                    </select>
                </div>
            </div>
        </div>
        
        <div class="dot-decoration">
            <div class="dot active"></div>
            <div class="dot"></div>
            <div class="dot"></div>
        </div>
        
        <div id="birthdayList" class="birthday-list"></div>
        
        <div class="timestamp" id="timestamp"></div>
    </div>

    <script>
        const scriptURL = 'https://script.google.com/macros/s/AKfycbxJu7ulUmBlSrBkJnx5XB4v-PPzb4Z03HuLCXbGcb9fqRPrm9wxdYmoZGOwcxM64Jpk/exec';
        const CACHE_DURATION = 24 * 60 * 60 * 1000; // 24시간 (밀리초)
        const CURRENT_YEAR = new Date().getFullYear(); // 2025년
        let birthdayData = [];
        let cachedFilteredData = [];
        let isLoading = false;
        let libraryWarningShown = false; // 라이브러리 경고 메시지 한 번만 표시
        let solarLunarLibraryLoaded = false; // 라이브러리 로드 상태
        
        // 음력 날짜를 올해 양력 날짜로 변환하는 함수
        function convertLunarToSolar(lunarDateStr, type) {
            if (type !== '음력' && type !== '음') {
                return null; // 양력이면 변환 불필요
            }
            
            try {
                let lunarMonth = null;
                let lunarDay = null;
                
                // "2024. 2. 22" 형식인 경우 (구글 시트 형식)
                const dotFormatMatch = lunarDateStr.match(/^(\d{4})\.\s*(\d{1,2})\.\s*(\d{1,2})/);
                if (dotFormatMatch) {
                    lunarMonth = parseInt(dotFormatMatch[2], 10);
                    lunarDay = parseInt(dotFormatMatch[3], 10);
                }
                // ISO 형식인 경우 (예: "2025-11-08T15:00:00.000Z")
                else if (lunarDateStr.includes('T') || lunarDateStr.match(/^\d{4}-\d{2}-\d{2}/)) {
                    const date = new Date(lunarDateStr);
                    if (!isNaN(date.getTime())) {
                        lunarMonth = date.getMonth() + 1;
                        lunarDay = date.getDate();
                    }
                } else {
                    // 날짜 문자열 파싱 (예: "06월 01일" 또는 "06.01" 또는 "6.1")
                    const match = lunarDateStr.match(/(\d{1,2})[월.\s]+(\d{1,2})/);
                    if (match) {
                        lunarMonth = parseInt(match[1], 10);
                        lunarDay = parseInt(match[2], 10);
                    }
                }
                
                if (!lunarMonth || !lunarDay) {
                    console.warn('음력 날짜 파싱 실패:', lunarDateStr);
                    return null;
                }
                
                // solarlunar.js를 사용하여 음력을 양력으로 변환
                // CDN 버전에서는 전역 변수로 접근 가능
                let solar = null;
                
                // 라이브러리 확인
                if (!solarLunarLibraryLoaded && !checkSolarLunarLibrary()) {
                    // 라이브러리가 아직 로드되지 않았으면 null 반환 (나중에 재시도)
                    return null;
                }
                
                // 여러 가능한 전역 변수 이름 시도
                if (typeof solarLunar !== 'undefined' && solarLunar.lunarToSolar) {
                    solar = solarLunar.lunarToSolar(CURRENT_YEAR, lunarMonth, lunarDay);
                } else if (typeof solarlunar !== 'undefined' && solarlunar.lunarToSolar) {
                    solar = solarlunar.lunarToSolar(CURRENT_YEAR, lunarMonth, lunarDay);
                } else if (typeof window.solarLunar !== 'undefined' && window.solarLunar.lunarToSolar) {
                    solar = window.solarLunar.lunarToSolar(CURRENT_YEAR, lunarMonth, lunarDay);
                } else if (typeof window.solarlunar !== 'undefined' && window.solarlunar.lunarToSolar) {
                    solar = window.solarlunar.lunarToSolar(CURRENT_YEAR, lunarMonth, lunarDay);
                } else {
                    // 경고 메시지는 한 번만 출력
                    if (!libraryWarningShown) {
                        console.warn('solarlunar.js 라이브러리를 찾을 수 없습니다. 음력 변환이 불가능합니다.');
                        libraryWarningShown = true;
                    }
                    return null;
                }
                
                if (solar && solar.year && solar.month && solar.day) {
                    // 년도는 올해로 고정 (정렬을 위해)
                    return new Date(CURRENT_YEAR, solar.month - 1, solar.day);
                }
                
                // 변환 실패 시 null 반환
                console.warn('음력 변환 실패:', { lunarMonth, lunarDay, solar });
                return null;
            } catch (error) {
                console.error('음력 변환 오류:', error, lunarDateStr);
                return null;
            }
        }
        
        // 데이터에 actualSolarDate 추가하는 함수
        function processBirthdayData(data) {
            if (!data || !Array.isArray(data)) {
                console.error('processBirthdayData: 데이터가 배열이 아닙니다', data);
                return [];
            }
            
            return data.map((person, index) => {
                // 필드명 확인 (구글 시트 구조에 맞게)
                // 시트: 생년월일 기초(F), 음/양(H)
                // 구글 앱스 스크립트가 반환하는 모든 가능한 필드명 확인
                const rawBirthday = person.birthday || person.생년월일 || person.생일 || person['생년월일 기초'] || 
                                   person['생년월일기초'] || person['Birthday'] || person['birthday'] || '';
                const type = person.type || person.음양 || person['음/양'] || person.lunar || 
                            person['Type'] || person['Lunar'] || '';
                
                // 원본 음력 날짜 찾기 (구글 시트의 F열: 생년월일 기초)
                // 구글 앱스 스크립트가 원본을 다른 필드명으로 반환할 수 있음
                // 가능한 모든 필드명 확인
                const originalLunarDate = person['생년월일 기초'] || person['생년월일기초'] || 
                                         person['원본'] || person['original'] || person['Original'] ||
                                         person['음력날짜'] || person['lunarDate'] || 
                                         person['lunarBirthday'] || person['LunarBirthday'] ||
                                         person['기초'] || person['기초날짜'] || null;
                
                // ISO 형식인 경우 "MM월 DD일" 형식으로 변환
                let birthdayStr = '';
                let month = null;
                let day = null;
                
                if (typeof rawBirthday === 'string') {
                    // "2024. 2. 22" 형식인 경우 (구글 시트 형식)
                    const dotFormatMatch = rawBirthday.match(/^(\d{4})\.\s*(\d{1,2})\.\s*(\d{1,2})/);
                    if (dotFormatMatch) {
                        month = parseInt(dotFormatMatch[2], 10);
                        day = parseInt(dotFormatMatch[3], 10);
                        birthdayStr = `${month}월 ${day}일`;
                    }
                    // ISO 형식인 경우 (예: "2025-11-08T15:00:00.000Z")
                    else if (rawBirthday.includes('T') || rawBirthday.match(/^\d{4}-\d{2}-\d{2}/)) {
                        const date = new Date(rawBirthday);
                        if (!isNaN(date.getTime())) {
                            month = date.getMonth() + 1;
                            day = date.getDate();
                            birthdayStr = `${month}월 ${day}일`;
                        }
                    } 
                    // 이미 "MM월 DD일" 형식인 경우
                    else {
                        const match = rawBirthday.match(/(\d{1,2})[월.\s]+(\d{1,2})/);
                        if (match) {
                            month = parseInt(match[1], 10);
                            day = parseInt(match[2], 10);
                            birthdayStr = rawBirthday;
                        } else {
                            birthdayStr = rawBirthday;
                        }
                    }
                } else if (rawBirthday instanceof Date) {
                    month = rawBirthday.getMonth() + 1;
                    day = rawBirthday.getDate();
                    birthdayStr = `${month}월 ${day}일`;
                } else {
                    birthdayStr = String(rawBirthday || '');
                }
                
                
                let actualSolarDate = null;
                const isLunar = type === '음력' || type === '음' || type === 'lunar';
                
                if (isLunar) {
                    // 음력 생일인 경우 올해 양력으로 변환
                    // 원본 음력 날짜를 사용하여 변환 (originalLunarDate가 있으면 사용, 없으면 birthdayStr 사용)
                    let lunarDateForConversion = originalLunarDate || birthdayStr;
                    
                    // originalLunarDate가 ISO 형식인 경우 "MM월 DD일" 형식으로 변환
                    if (lunarDateForConversion && (lunarDateForConversion.includes('T') || lunarDateForConversion.match(/^\d{4}-\d{2}-\d{2}/))) {
                        const date = new Date(lunarDateForConversion);
                        if (!isNaN(date.getTime())) {
                            lunarDateForConversion = `${date.getMonth() + 1}월 ${date.getDate()}일`;
                        }
                    } else if (lunarDateForConversion && lunarDateForConversion.match(/^(\d{4})\.\s*(\d{1,2})\.\s*(\d{1,2})/)) {
                        // "2024. 2. 22" 형식인 경우
                        const match = lunarDateForConversion.match(/^(\d{4})\.\s*(\d{1,2})\.\s*(\d{1,2})/);
                        if (match) {
                            lunarDateForConversion = `${parseInt(match[2], 10)}월 ${parseInt(match[3], 10)}일`;
                        }
                    }
                    
                    actualSolarDate = convertLunarToSolar(lunarDateForConversion, type);
                    
                    // 변환이 실패하면 라이브러리가 아직 로드되지 않았을 수 있음
                    // 나중에 재시도할 수 있도록 null로 두기
                } else {
                    // 양력 생일인 경우
                    if (month && day) {
                        actualSolarDate = new Date(CURRENT_YEAR, month - 1, day);
                    } else {
                        // 파싱 실패 시 재시도
                        const match = birthdayStr.match(/(\d{1,2})[월.\s]+(\d{1,2})/);
                        if (match) {
                            month = parseInt(match[1], 10);
                            day = parseInt(match[2], 10);
                            actualSolarDate = new Date(CURRENT_YEAR, month - 1, day);
                        }
                    }
                }
                
                // 원본 음력 날짜 보존
                // 중요: 구글 앱스 스크립트가 F열(생년월일 기초)을 반환해야 함
                // originalLunarDate가 있으면 사용, 없으면 birthdayStr을 원본으로 간주
                // (구글 앱스 스크립트가 이미 변환된 날짜만 반환한다면, 
                //  구글 앱스 스크립트를 수정하여 F열을 반환하도록 해야 함)
                let finalOriginalLunar = null;
                if (isLunar) {
                    if (originalLunarDate) {
                        // 원본 음력 날짜가 별도 필드로 온 경우
                        // "MM월 DD일" 형식으로 정규화
                        let normalizedOriginal = originalLunarDate;
                        if (normalizedOriginal.includes('T') || normalizedOriginal.match(/^\d{4}-\d{2}-\d{2}/)) {
                            // ISO 형식인 경우
                            const date = new Date(normalizedOriginal);
                            if (!isNaN(date.getTime())) {
                                normalizedOriginal = `${date.getMonth() + 1}월 ${date.getDate()}일`;
                            }
                        } else if (normalizedOriginal.match(/^(\d{4})\.\s*(\d{1,2})\.\s*(\d{1,2})/)) {
                            // "2024. 2. 22" 형식인 경우
                            const match = normalizedOriginal.match(/^(\d{4})\.\s*(\d{1,2})\.\s*(\d{1,2})/);
                            if (match) {
                                normalizedOriginal = `${parseInt(match[2], 10)}월 ${parseInt(match[3], 10)}일`;
                            }
                        }
                        finalOriginalLunar = normalizedOriginal;
                    } else {
                        // 구글 앱스 스크립트가 원본을 반환하지 않는 경우
                        // birthdayStr을 원본 음력 날짜로 간주
                        // (실제로는 구글 앱스 스크립트를 수정하여 F열을 반환하도록 해야 함)
                        finalOriginalLunar = birthdayStr;
                    }
                }
                
                return {
                    ...person,
                    birthday: birthdayStr, // "MM월 DD일" 형식으로 저장
                    originalLunarBirthday: finalOriginalLunar, // 음력 생일자의 원본 날짜 보존
                    type: type,
                    actualSolarDate: actualSolarDate,
                    isLunar: isLunar
                };
            });
        }
        
        // 날짜 포맷팅 함수 (표기 방식 변경)
        function formatDate(person) {
            // birthday 필드에서 날짜 문자열 추출 (원본 데이터 보존)
            let birthdayStr = person.birthday || person.생년월일 || person.생일 || person['생년월일 기초'] || '';
            
            // 문자열이 아닌 경우 변환
            if (typeof birthdayStr !== 'string') {
                if (birthdayStr instanceof Date) {
                    // Date 객체인 경우 MM월 DD일 형식으로 변환
                    const month = birthdayStr.getMonth() + 1;
                    const day = birthdayStr.getDate();
                    birthdayStr = `${month}월 ${day}일`;
                } else {
                    birthdayStr = String(birthdayStr || '');
                }
            }
            
            // ISO 날짜 형식인 경우 파싱 (예: "2024-02-21T15:00:00.000Z")
            if (birthdayStr.includes('T') || birthdayStr.match(/^\d{4}-\d{2}-\d{2}/)) {
                try {
                    const date = new Date(birthdayStr);
                    if (!isNaN(date.getTime())) {
                        const month = date.getMonth() + 1;
                        const day = date.getDate();
                        birthdayStr = `${month}월 ${day}일`;
                    }
                } catch (e) {
                    console.warn('날짜 파싱 오류:', e, birthdayStr);
                }
            }
            
            // MM월 DD일 형식이 아닌 경우 정규화 시도
            if (!birthdayStr.includes('월') && !birthdayStr.includes('일')) {
                const match = birthdayStr.match(/(\d{1,2})[월.\s\-/]+(\d{1,2})/);
                if (match) {
                    const month = parseInt(match[1], 10);
                    const day = parseInt(match[2], 10);
                    birthdayStr = `${month}월 ${day}일`;
                }
            }
            
            // 빈 문자열인 경우 처리
            if (!birthdayStr || birthdayStr.trim() === '') {
                birthdayStr = '날짜 없음';
            }
            
            if (person.isLunar) {
                // 음력 생일자: 원본 음력 날짜 + 양력 변환 날짜 함께 표기
                // 원본 음력 날짜 사용 (originalLunarBirthday가 있으면 사용, 없으면 birthday 사용)
                const originalLunar = person.originalLunarBirthday || birthdayStr;
                
                if (person.actualSolarDate) {
                    try {
                        // Date 객체인지 확인하고 변환
                        const date = person.actualSolarDate instanceof Date 
                            ? person.actualSolarDate 
                            : new Date(person.actualSolarDate);
                        if (!isNaN(date.getTime())) {
                            const solarMonth = date.getMonth() + 1;
                            const solarDay = date.getDate();
                            // 형식: 음력 MM월 DD일 MM월 DD일 (한 줄에 표시)
                            return {
                                isLunar: true,
                                text: `음력 ${originalLunar} ${solarMonth}월 ${solarDay}일`
                            };
                        }
                    } catch (e) {
                        console.warn('양력 변환 날짜 파싱 오류:', e, person.actualSolarDate);
                    }
                }
                // 변환 실패 시 원래 형식 유지
                return {
                    isLunar: true,
                    text: `음력 ${originalLunar}`
                };
            } else {
                // 양력 생일자: 양력 날짜만 표시 (양력 표시 제거)
                return {
                    isLunar: false,
                    text: birthdayStr
                };
            }
        }

        function getMonthFromDate(person) {
            // actualSolarDate가 있으면 우선 사용
            if (person.actualSolarDate) {
                try {
                    let date = null;
                    if (person.actualSolarDate instanceof Date) {
                        date = person.actualSolarDate;
                    } else if (typeof person.actualSolarDate === 'string') {
                        date = new Date(person.actualSolarDate);
                    } else {
                        // 다른 형식인 경우
                        date = new Date(person.actualSolarDate);
                    }
                    
                    if (date && !isNaN(date.getTime())) {
                        const month = date.getMonth() + 1;
                        return month;
                    }
                } catch (e) {
                    console.warn('getMonthFromDate actualSolarDate 파싱 오류:', e, person);
                }
            }
            
            // fallback: 원래 날짜에서 추출
            const birthdayStr = String(person.birthday || person.생년월일 || person.생일 || person['생년월일 기초'] || '');
            
            // "2024. 2. 22" 형식인 경우 (구글 시트 형식)
            const dotFormatMatch = birthdayStr.match(/^(\d{4})\.\s*(\d{1,2})\.\s*(\d{1,2})/);
            if (dotFormatMatch) {
                return parseInt(dotFormatMatch[2], 10);
            }
            
            // MM월 DD일 형식
            const match = birthdayStr.match(/(\d{1,2})[월.\s]+/);
            if (match) {
                return parseInt(match[1], 10);
            }
            
            // ISO 형식인 경우
            if (birthdayStr.includes('T') || birthdayStr.match(/^\d{4}-\d{2}-\d{2}/)) {
                try {
                    const date = new Date(birthdayStr);
                    if (!isNaN(date.getTime())) {
                        return date.getMonth() + 1;
                    }
                } catch (e) {
                    // 무시
                }
            }
            
            console.warn('getMonthFromDate: 월을 추출할 수 없음', person);
            return 0; // 필터링에서 제외되도록 0 반환
        }

        // 디바운스 처리를 위한 함수
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        // 로딩 상태 표시 함수
        function showLoading() {
            isLoading = true;
            document.getElementById('birthdayList').innerHTML = 
                '<div class="loading"><div class="loading-spinner"></div><div>데이터를 불러오는 중...</div></div>';
        }

        // 필터링 및 정렬을 한번에 처리하는 함수
        function filterBirthdays() {
            const selectedMonth = document.getElementById('monthSelect').value;
            const selectedDepartment = document.getElementById('departmentSelect').value;
            
            // 로컬 스토리지에 선택값 저장
            localStorage.setItem('selectedMonth', selectedMonth);
            localStorage.setItem('selectedDepartment', selectedDepartment);
            
            // 데이터가 없으면 리턴
            if (!birthdayData || !Array.isArray(birthdayData) || birthdayData.length === 0) {
                console.warn('필터링: 데이터가 없습니다');
                document.getElementById('birthdayList').innerHTML = 
                    '<div class="no-birthdays">데이터를 불러오는 중...</div>';
                return;
            }
            
            // 보여주기 전에 로딩 상태 표시
            if (isLoading) {
                showLoading();
            }
            
            // UI 렌더링을 다음 프레임으로 지연
            requestAnimationFrame(() => {
                let filteredData = [...birthdayData]; // 원본 데이터 복사
    
                // 월 필터링 (actualSolarDate 기준, 없으면 birthday에서 추출)
                if (selectedMonth !== 'all') {
                    const monthInt = parseInt(selectedMonth);
                    filteredData = filteredData.filter(person => {
                        const month = getMonthFromDate(person);
                        const matches = month === monthInt && month > 0;
                        return matches;
                    });
                }
    
                // 소속 필터링
                if (selectedDepartment !== 'all') {
                    filteredData = filteredData.filter(person => {
                        const dept = person.소속 || person['소속'] || '';
                        return dept === selectedDepartment;
                    });
                }
    
                // actualSolarDate 기준으로 정렬 (올해 생일이 빠른 순서대로)
                if (!arraysEqual(filteredData, cachedFilteredData)) {
                    filteredData.sort((a, b) => {
                        // actualSolarDate를 Date 객체로 변환 (캐시에서 불러올 때 문자열일 수 있음)
                        let dateA = null;
                        let dateB = null;
                        
                        try {
                            if (a.actualSolarDate) {
                                if (a.actualSolarDate instanceof Date) {
                                    dateA = a.actualSolarDate;
                                } else {
                                    dateA = new Date(a.actualSolarDate);
                                }
                                // 유효하지 않은 날짜인지 확인
                                if (isNaN(dateA.getTime())) {
                                    dateA = null;
                                }
                            }
                        } catch (e) {
                            dateA = null;
                        }
                        
                        try {
                            if (b.actualSolarDate) {
                                if (b.actualSolarDate instanceof Date) {
                                    dateB = b.actualSolarDate;
                                } else {
                                    dateB = new Date(b.actualSolarDate);
                                }
                                // 유효하지 않은 날짜인지 확인
                                if (isNaN(dateB.getTime())) {
                                    dateB = null;
                                }
                            }
                        } catch (e) {
                            dateB = null;
                        }
                        
                        // actualSolarDate가 없는 경우를 처리
                        // null인 경우는 birthday에서 월/일을 추출하여 비교 (양력/음력 구분 없이 함께 정렬)
                        if (!dateA && !dateB) {
                            // 둘 다 null이면 birthday로 비교
                            const monthA = getMonthFromDate(a);
                            const monthB = getMonthFromDate(b);
                            if (monthA !== monthB) return monthA - monthB;
                            const dayA = parseInt((a.birthday || '').match(/(\d{1,2})일/)?.[1] || '0', 10);
                            const dayB = parseInt((b.birthday || '').match(/(\d{1,2})일/)?.[1] || '0', 10);
                            return dayA - dayB;
                        }
                        if (!dateA) {
                            // dateA가 null이면 birthday에서 추출하여 비교
                            const monthA = getMonthFromDate(a);
                            const monthB = dateB.getMonth() + 1;
                            if (monthA !== monthB) return monthA - monthB;
                            const dayA = parseInt((a.birthday || '').match(/(\d{1,2})일/)?.[1] || '0', 10);
                            const dayB = dateB.getDate();
                            return dayA - dayB;
                        }
                        if (!dateB) {
                            // dateB가 null이면 birthday에서 추출하여 비교
                            const monthA = dateA.getMonth() + 1;
                            const monthB = getMonthFromDate(b);
                            if (monthA !== monthB) return monthA - monthB;
                            const dayA = dateA.getDate();
                            const dayB = parseInt((b.birthday || '').match(/(\d{1,2})일/)?.[1] || '0', 10);
                            return dayA - dayB;
                        }
                        
                        // 날짜 비교 (년도 무시, 월/일만 비교)
                        try {
                            // 년도를 올해로 고정하여 비교 (정렬을 위해)
                            const monthA = dateA.getMonth() + 1;
                            const dayA = dateA.getDate();
                            const monthB = dateB.getMonth() + 1;
                            const dayB = dateB.getDate();
                            
                            // 월 비교
                            if (monthA !== monthB) {
                                return monthA - monthB;
                            }
                            // 일 비교
                            return dayA - dayB;
                        } catch (e) {
                            return 0;
                        }
                    });
                    
                    cachedFilteredData = filteredData;
                }
    
                renderBirthdayList(filteredData);
                isLoading = false;
            });
        }
        
        // 배열 비교 함수
        function arraysEqual(a, b) {
            if (a === b) return true;
            if (a.length !== b.length) return false;
            for (let i = 0; i < a.length; i++) {
                if (a[i] !== b[i]) return false;
            }
            return true;
        }
        
        // 렌더링 함수 분리
        function renderBirthdayList(data) {
            const birthdayList = document.getElementById('birthdayList');
            
            if (data.length === 0) {
                birthdayList.innerHTML = '<div class="no-birthdays">해당하는 생일자가 없습니다.</div>';
                return;
            }
            
            // DOM 조작 최소화
            const fragment = document.createDocumentFragment();
            
            data.forEach(person => {
                const item = document.createElement('div');
                item.className = 'birthday-item';
                
                const personInfo = document.createElement('div');
                personInfo.className = 'person-info';
                
                const namePosition = document.createElement('div');
                namePosition.className = 'name-position';
                namePosition.textContent = `${person.name} ${person.position || ''}`;
                
                const department = document.createElement('div');
                department.className = 'department';
                department.textContent = person.소속 || '';
                
                personInfo.appendChild(namePosition);
                personInfo.appendChild(department);
                
                const birthdayInfo = document.createElement('div');
                const formattedDate = formatDate(person);
                
                // formatDate가 객체인지 확인
                if (formattedDate && typeof formattedDate === 'object' && 'isLunar' in formattedDate) {
                    // 양력/음력 모두 한 줄로 표시
                    birthdayInfo.className = 'birthday-info';
                    birthdayInfo.textContent = formattedDate.text || (person.birthday || '');
                } else {
                    // fallback: 문자열인 경우 (이전 형식 호환)
                    birthdayInfo.className = 'birthday-info';
                    const fallbackText = typeof formattedDate === 'string' ? formattedDate : (person.birthday || '');
                    birthdayInfo.textContent = fallbackText;
                }
                
                item.appendChild(personInfo);
                item.appendChild(birthdayInfo);
                fragment.appendChild(item);
            });
            
            // 한 번에 DOM 갱신
            birthdayList.innerHTML = '';
            birthdayList.appendChild(fragment);
            
            // 필터링 결과 통계 업데이트
            updateFilterStats(data.length);
        }
        
        // 필터링 결과 통계 표시
        function updateFilterStats(count) {
            const stats = document.getElementById('filterStats');
            if (stats) {
                stats.textContent = `총 ${count}명`;
            }
        }
        
        // 디바운스된 필터 함수
        const debouncedFilter = debounce(filterBirthdays, 100);
        
        // 필터 변경 이벤트 리스너
        function setupEventListeners() {
            const monthSelect = document.getElementById('monthSelect');
            const departmentSelect = document.getElementById('departmentSelect');
            
            monthSelect.addEventListener('change', debouncedFilter);
            departmentSelect.addEventListener('change', debouncedFilter);
            
            // 필터 리셋 버튼 이벤트
            const resetButton = document.getElementById('resetFilters');
            if (resetButton) {
                resetButton.addEventListener('click', function() {
                    monthSelect.value = 'all';
                    departmentSelect.value = 'all';
                    debouncedFilter();
                });
            }
        }

        // Date 객체 복원 함수 (캐시에서 불러올 때 사용)
        function restoreDateObjects(data) {
            if (!Array.isArray(data)) {
                console.warn('restoreDateObjects: 데이터가 배열이 아닙니다', data);
                return data;
            }
            return data.map((person, index) => {
                try {
                    if (person.actualSolarDate) {
                        // 이미 Date 객체인 경우
                        if (person.actualSolarDate instanceof Date) {
                            // 유효한지 확인
                            if (isNaN(person.actualSolarDate.getTime())) {
                                return { ...person, actualSolarDate: null };
                            }
                            return person;
                        }
                        
                        // 문자열이나 다른 형식인 경우 Date 객체로 변환
                        const dateStr = person.actualSolarDate;
                        const date = new Date(dateStr);
                        
                        if (isNaN(date.getTime())) {
                            console.warn(`[${index}] 유효하지 않은 날짜:`, dateStr);
                            return { ...person, actualSolarDate: null };
                        }
                        
                        return {
                            ...person,
                            actualSolarDate: date
                        };
                    }
                    return person;
                } catch (error) {
                    console.error(`[${index}] Date 복원 오류:`, error, person);
                    return { ...person, actualSolarDate: null };
                }
            });
        }
        
        // localStorage에서 캐시된 데이터 확인
        function getCachedData() {
            try {
                const cached = localStorage.getItem('birthdayDataCache');
                if (!cached) return null;
                
                const { data, timestamp } = JSON.parse(cached);
                const now = new Date().getTime();
                
                // 24시간 이내의 캐시인지 확인
                if (now - timestamp < CACHE_DURATION) {
                    // Date 객체 복원
                    return restoreDateObjects(data);
                } else {
                    // 만료된 캐시 삭제
                    localStorage.removeItem('birthdayDataCache');
                    return null;
                }
            } catch (error) {
                console.error('캐시 읽기 오류:', error);
                return null;
            }
        }
        
        // localStorage에 데이터 캐싱
        function setCachedData(data) {
            try {
                const cache = {
                    data: data,
                    timestamp: new Date().getTime()
                };
                localStorage.setItem('birthdayDataCache', JSON.stringify(cache));
            } catch (error) {
                console.error('캐시 저장 오류:', error);
            }
        }
        
        // 데이터 초기 로드
        async function loadBirthdayData(forceRefresh = false) {
            // 캐시된 데이터 확인 (강제 새로고침이 아닌 경우만)
            if (!forceRefresh) {
                const cachedData = getCachedData();
                if (cachedData && Array.isArray(cachedData) && cachedData.length > 0) {
                    // 라이브러리가 로드될 때까지 대기 후 처리
                    if (!solarLunarLibraryLoaded) {
                        waitForSolarLunarLibrary(() => {
                            // 캐시에서 데이터 로드 - processBirthdayData로 다시 처리
                            birthdayData = processBirthdayData(cachedData);
                            restoreFilterSettings();
                            filterBirthdays();
                            updateTimestamp();
                        });
                        return; // 네트워크 요청 건너뛰기
                    } else {
                        // 라이브러리가 이미 로드된 경우 바로 처리
                        birthdayData = processBirthdayData(cachedData);
                        restoreFilterSettings();
                        filterBirthdays();
                        updateTimestamp();
                        return; // 네트워크 요청 건너뛰기
                    }
                }
            } else {
                // 강제 새로고침 시 캐시 삭제
                localStorage.removeItem('birthdayDataCache');
            }
            
            // 캐시가 없거나 만료된 경우 네트워크에서 로드
            showLoading();
            
            try {
                // 캐시 버스팅을 위한 타임스탬프 추가
                const timestamp = new Date().getTime();
                const url = `${scriptURL}?t=${timestamp}`;
                
                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error('네트워크 응답이 올바르지 않습니다');
                }
                
                const data = await response.json();
                // 데이터 구조 확인 및 변환
                let rawData = data.birthdays || data || [];
                
                if (!Array.isArray(rawData) || rawData.length === 0) {
                    throw new Error('데이터가 비어있거나 올바른 형식이 아닙니다');
                }
                
                // 데이터 가공: actualSolarDate 계산
                rawData = processBirthdayData(rawData);
                
                // 캐시에 저장
                setCachedData(rawData);
                
                birthdayData = rawData;
                
                // 초기 필터 값 설정 (로컬 스토리지에서 복원)
                restoreFilterSettings();
                
                // 필터 적용
                filterBirthdays();
                
                // 마지막 업데이트 시간 표시
                updateTimestamp();
                
            } catch (error) {
                console.error('데이터 로드 오류:', error);
                console.error('오류 상세:', error.message, error.stack);
                document.getElementById('birthdayList').innerHTML = 
                    `<div class="no-birthdays">데이터를 불러오는데 실패했습니다.<br>
                    <small style="color: #999; margin-top: 8px; display: block;">오류: ${error.message}</small><br>
                    <button id="retryButton" class="retry-button">다시 시도</button></div>`;
                
                // 재시도 버튼 이벤트 리스너
                const retryButton = document.getElementById('retryButton');
                if (retryButton) {
                    retryButton.addEventListener('click', () => loadBirthdayData(true)); // 강제 새로고침
                }
            } finally {
                isLoading = false;
            }
        }
        
        // 필터 설정 복원
        function restoreFilterSettings() {
            const monthSelect = document.getElementById('monthSelect');
            const departmentSelect = document.getElementById('departmentSelect');
            
            // 기본값: 현재 월, 전체 부서
            const currentMonth = new Date().getMonth() + 1;
            const savedMonth = localStorage.getItem('selectedMonth');
            const savedDepartment = localStorage.getItem('selectedDepartment');
            
            // 저장된 값이 있으면 사용, 없으면 기본값
            monthSelect.value = savedMonth || String(currentMonth);
            departmentSelect.value = savedDepartment || 'all';
        }
        
        // 타임스탬프 업데이트
        function updateTimestamp() {
            const now = new Date();
            document.getElementById('timestamp').textContent = 
                `마지막 업데이트: ${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}-${String(now.getDate()).padStart(2, '0')} ${String(now.getHours()).padStart(2, '0')}:${String(now.getMinutes()).padStart(2, '0')}`;
        }

        // 라이브러리 확인 함수
        function checkSolarLunarLibrary() {
            return (typeof solarLunar !== 'undefined' && solarLunar.lunarToSolar) ||
                   (typeof solarlunar !== 'undefined' && solarlunar.lunarToSolar) ||
                   (typeof window.solarLunar !== 'undefined' && window.solarLunar.lunarToSolar) ||
                   (typeof window.solarlunar !== 'undefined' && window.solarlunar.lunarToSolar);
        }
        
        // solarlunar.js 라이브러리 로드 확인 및 대기
        function waitForSolarLunarLibrary(callback) {
            let checked = false;
            
            const checkInterval = setInterval(() => {
                const hasLibrary = checkSolarLunarLibrary();
                
                if (hasLibrary && !checked) {
                    solarLunarLibraryLoaded = true;
                    checked = true;
                    clearInterval(checkInterval);
                    if (callback) callback();
                } else if (document.readyState === 'complete' && !checked) {
                    // 페이지 로드 완료 후에도 라이브러리가 없으면 경고하지만 계속 진행
                    if (!hasLibrary) {
                        console.warn('solarlunar.js 라이브러리를 찾을 수 없습니다. 음력 변환이 작동하지 않을 수 있습니다.');
                    } else {
                        solarLunarLibraryLoaded = true;
                    }
                    checked = true;
                    clearInterval(checkInterval);
                    if (callback) callback();
                }
            }, 100);
            
            // 5초 후 타임아웃 (라이브러리가 없어도 진행)
            setTimeout(() => {
                if (!checked) {
                    const hasLibrary = checkSolarLunarLibrary();
                    if (!hasLibrary) {
                        console.warn('solarlunar.js 라이브러리 로드 타임아웃. 음력 변환이 작동하지 않을 수 있습니다.');
                    } else {
                        solarLunarLibraryLoaded = true;
                    }
                    checked = true;
                    clearInterval(checkInterval);
                    if (callback) callback();
                }
            }, 5000);
        }
        
        // 페이지 로드 시 실행
        window.addEventListener('DOMContentLoaded', function() {
            setupEventListeners();
            // 라이브러리 로드를 기다린 후 데이터 로드
            waitForSolarLunarLibrary(() => {
                loadBirthdayData();
            });
        });
    </script>
</body>
</html>
